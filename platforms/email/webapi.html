<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>kibicara.platforms.email.webapi API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kibicara.platforms.email.webapi</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (C) 2020 by Maike &lt;maike@systemli.org&gt;
# Copyright (C) 2020 by Cathy Hu &lt;cathy.hu@fau.de&gt;
# Copyright (C) 2020 by Thomas Lindner &lt;tom@dl6tom.de&gt;
#
# SPDX-License-Identifier: 0BSD

from fastapi import APIRouter, Depends, HTTPException, Response, status
from kibicara import email
from kibicara.platforms.email.bot import spawner
from kibicara.platforms.email.model import Email, EmailSubscribers
from kibicara.platformapi import Message
from kibicara.config import config
from kibicara.webapi.admin import from_token, to_token
from kibicara.webapi.hoods import get_hood, get_hood_unauthorized
from logging import getLogger
from nacl import exceptions
from ormantic.exceptions import NoMatch
from os import urandom
from pydantic import BaseModel, validator
from smtplib import SMTPException
from sqlite3 import IntegrityError


logger = getLogger(__name__)


class BodyEmail(BaseModel):
    name: str

    @validator(&#39;name&#39;)
    def valid_prefix(cls, value):
        if not value.startswith(&#39;kibicara-&#39;):
            raise ValueError(&#39;Recipient address didn\&#39;t start with kibicara-&#39;)
        return value


class BodyEmailPublic(BaseModel):
    name: str


class BodyMessage(BaseModel):
    &#34;&#34;&#34; This model shows which values are supplied by the MDA listener script. &#34;&#34;&#34;

    text: str
    secret: str


class BodySubscriber(BaseModel):
    &#34;&#34;&#34; This model holds the email address of a fresh subscriber. &#34;&#34;&#34;

    email: str


async def get_email(email_id: int, hood=Depends(get_hood)):
    &#34;&#34;&#34;Get Email row by hood.
    You can specify an email_id to nail it down, but it works without as well.

    :param hood: Hood the Email bot belongs to.
    :return: Email row of the found email bot.
    &#34;&#34;&#34;
    try:
        return await Email.objects.get(id=email_id, hood=hood)
    except NoMatch:
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND)


async def get_subscriber(subscriber_id: int, hood=Depends(get_hood)):
    try:
        return await EmailSubscribers.objects.get(id=subscriber_id, hood=hood)
    except NoMatch:
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND)


# registers the routes, gets imported in /kibicara/webapi/__init__.py
router = APIRouter()


@router.get(
    &#39;/public&#39;,
    # TODO response_model
    operation_id=&#39;get_emails_public&#39;,
)
async def email_read_all_public(hood=Depends(get_hood_unauthorized)):
    if hood.email_enabled:
        emails = await Email.objects.filter(hood=hood).all()
        return [BodyEmailPublic(name=email.name) for email in emails]
    return []


@router.get(
    &#39;/&#39;,
    # TODO response_model
    operation_id=&#39;get_emails&#39;,
)
async def email_read_all(hood=Depends(get_hood)):
    return await Email.objects.filter(hood=hood).select_related(&#39;hood&#39;).all()


@router.post(
    &#39;/&#39;,
    status_code=status.HTTP_201_CREATED,
    # TODO response_model
    operation_id=&#39;create_email&#39;,
)
async def email_create(values: BodyEmail, response: Response, hood=Depends(get_hood)):
    &#34;&#34;&#34;Create an Email bot. Call this when creating a hood.

    :param hood: Hood row of the hood the Email bot is supposed to belong to.
    :return: Email row of the new email bot.
    &#34;&#34;&#34;
    try:
        email = await Email.objects.create(
            hood=hood, secret=urandom(32).hex(), **values.__dict__
        )
        response.headers[&#39;Location&#39;] = &#39;%d&#39; % hood.id
        return email
    except IntegrityError:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT)


@router.get(
    &#39;/status&#39;,
    status_code=status.HTTP_200_OK,
    # TODO response_model
    operation_id=&#39;status_email&#39;,
)
async def email_status(hood=Depends(get_hood)):
    return {&#39;status&#39;: spawner.get(hood).status.name}


@router.post(
    &#39;/start&#39;,
    status_code=status.HTTP_200_OK,
    # TODO response_model
    operation_id=&#39;start_email&#39;,
)
async def email_start(hood=Depends(get_hood)):
    await hood.update(email_enabled=True)
    spawner.get(hood).start()
    return {}


@router.post(
    &#39;/stop&#39;,
    status_code=status.HTTP_200_OK,
    # TODO response_model
    operation_id=&#39;stop_email&#39;,
)
async def email_stop(hood=Depends(get_hood)):
    await hood.update(email_enabled=False)
    spawner.get(hood).stop()
    return {}


@router.get(
    &#39;/{email_id}&#39;,
    # TODO response_model
    operation_id=&#39;get_email&#39;,
)
async def email_read(email=Depends(get_email)):
    return email


@router.delete(
    &#39;/{email_id}&#39;, status_code=status.HTTP_204_NO_CONTENT, operation_id=&#39;delete_email&#39;
)
async def email_delete(email=Depends(get_email)):
    &#34;&#34;&#34;Delete an Email bot.
    Stops and deletes the Email bot.

    :param hood: Hood the Email bot belongs to.
    &#34;&#34;&#34;
    await email.delete()
    return Response(status_code=status.HTTP_204_NO_CONTENT)


@router.post(
    &#39;/subscribe/&#39;,
    status_code=status.HTTP_202_ACCEPTED,
    operation_id=&#39;subscribe&#39;,
    response_model=BaseModel,
)
async def email_subscribe(
    subscriber: BodySubscriber, hood=Depends(get_hood_unauthorized)
):
    &#34;&#34;&#34;Send a confirmation mail to subscribe to messages via email.

    :param subscriber: Subscriber object, holds the email address.
    :param hood: Hood the Email bot belongs to.
    :return: Returns status code 200 after sending confirmation email.
    &#34;&#34;&#34;
    token = to_token(hood=hood.id, email=subscriber.email)
    confirm_link = &#39;%s/hoods/%d/email-confirm?token=%s&#39; % (
        config[&#39;frontend_url&#39;],
        hood.id,
        token,
    )
    try:
        subs = await EmailSubscribers.objects.filter(email=subscriber.email).all()
        if subs:
            raise HTTPException(status_code=status.HTTP_409_CONFLICT)
        email.send_email(
            subscriber.email,
            &#34;Subscribe to Kibicara &#34; + hood.name,
            sender=hood.name,
            body=&#39;To confirm your subscription, follow this link: &#39; + confirm_link,
        )
        return {}
    except ConnectionRefusedError:
        logger.info(token)
        logger.error(&#34;Sending subscription confirmation email failed.&#34;, exc_info=True)
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY)
    except SMTPException:
        logger.info(token)
        logger.error(&#34;Sending subscription confirmation email failed.&#34;, exc_info=True)
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY)


@router.post(
    &#39;/subscribe/confirm/{token}&#39;,
    status_code=status.HTTP_201_CREATED,
    operation_id=&#39;confirm_subscriber&#39;,
    response_model=BaseModel,
)
async def email_subscribe_confirm(token, hood=Depends(get_hood_unauthorized)):
    &#34;&#34;&#34;Confirm a new subscriber and add them to the database.

    :param token: encrypted JSON token, holds the email of the subscriber.
    :param hood: Hood the Email bot belongs to.
    :return: Returns status code 200 after adding the subscriber to the database.
    &#34;&#34;&#34;
    payload = from_token(token)
    # If token.hood and url.hood are different, raise an error:
    if hood.id is not payload[&#39;hood&#39;]:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST)
    try:
        await EmailSubscribers.objects.create(hood=hood.id, email=payload[&#39;email&#39;])
        return {}
    except IntegrityError:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT)


@router.delete(
    &#39;/unsubscribe/{token}&#39;,
    status_code=status.HTTP_204_NO_CONTENT,
    operation_id=&#39;unsubscribe&#39;,
)
async def email_unsubscribe(token, hood=Depends(get_hood_unauthorized)):
    &#34;&#34;&#34;Remove a subscriber from the database when they click on an unsubscribe link.

    :param token: encrypted JSON token, holds subscriber email + hood.id.
    :param hood: Hood the Email bot belongs to.
    &#34;&#34;&#34;
    try:
        logger.warning(&#34;token is: &#34; + token)
        payload = from_token(token)
        # If token.hood and url.hood are different, raise an error:
        if hood.id is not payload[&#39;hood&#39;]:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST)
        subscriber = await EmailSubscribers.objects.filter(
            hood=payload[&#39;hood&#39;], email=payload[&#39;email&#39;]
        ).get()
        await subscriber.delete()
        return Response(status_code=status.HTTP_204_NO_CONTENT)
    except NoMatch:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)
    except exceptions.CryptoError:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST)


@router.get(
    &#39;/subscribers/&#39;,
    # TODO response_model
    operation_id=&#39;get_subscribers&#39;,
)
async def subscribers_read_all(hood=Depends(get_hood)):
    return await EmailSubscribers.objects.filter(hood=hood).all()


@router.get(
    &#39;/subscribers/{subscriber_id}&#39;,
    # TODO response_model
    operation_id=&#39;get_subscriber&#39;,
)
async def subscribers_read(subscriber=Depends(get_subscriber)):
    return subscriber


@router.post(
    &#39;/messages/&#39;,
    status_code=status.HTTP_201_CREATED,
    # TODO response_model
    operation_id=&#39;send_message&#39;,
)
async def email_message_create(
    message: BodyMessage, hood=Depends(get_hood_unauthorized)
):
    &#34;&#34;&#34;Receive a message from the MDA and pass it to the censor.

    :param message: BodyMessage object, holds the message.
    :param hood: Hood the Email bot belongs to.
    :return: returns status code 201 if the message is accepted by the censor.
    &#34;&#34;&#34;
    for receiver in await Email.objects.filter(hood=hood).all():
        if message.secret == receiver.secret:
            # pass message.text to bot.py
            if await spawner.get(hood).publish(Message(message.text)):
                logger.warning(&#34;Message was accepted: &#34; + message.text)
                return {}
            else:
                logger.warning(&#34;Message was&#39;t accepted: &#34; + message.text)
                raise HTTPException(
                    status_code=status.HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS
                )
    logger.warning(
        &#34;Someone is trying to submit an email without the correct API secret&#34;
    )
    raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="kibicara.platforms.email.webapi.email_create"><code class="name flex">
<span>async def <span class="ident">email_create</span></span>(<span>values: <a title="kibicara.platforms.email.webapi.BodyEmail" href="#kibicara.platforms.email.webapi.BodyEmail">BodyEmail</a>, response: starlette.responses.Response, hood=Depends(get_hood))</span>
</code></dt>
<dd>
<div class="desc"><p>Create an Email bot. Call this when creating a hood.</p>
<p>:param hood: Hood row of the hood the Email bot is supposed to belong to.
:return: Email row of the new email bot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.post(
    &#39;/&#39;,
    status_code=status.HTTP_201_CREATED,
    # TODO response_model
    operation_id=&#39;create_email&#39;,
)
async def email_create(values: BodyEmail, response: Response, hood=Depends(get_hood)):
    &#34;&#34;&#34;Create an Email bot. Call this when creating a hood.

    :param hood: Hood row of the hood the Email bot is supposed to belong to.
    :return: Email row of the new email bot.
    &#34;&#34;&#34;
    try:
        email = await Email.objects.create(
            hood=hood, secret=urandom(32).hex(), **values.__dict__
        )
        response.headers[&#39;Location&#39;] = &#39;%d&#39; % hood.id
        return email
    except IntegrityError:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT)</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.email_delete"><code class="name flex">
<span>async def <span class="ident">email_delete</span></span>(<span>email=Depends(get_email))</span>
</code></dt>
<dd>
<div class="desc"><p>Delete an Email bot.
Stops and deletes the Email bot.</p>
<p>:param hood: Hood the Email bot belongs to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.delete(
    &#39;/{email_id}&#39;, status_code=status.HTTP_204_NO_CONTENT, operation_id=&#39;delete_email&#39;
)
async def email_delete(email=Depends(get_email)):
    &#34;&#34;&#34;Delete an Email bot.
    Stops and deletes the Email bot.

    :param hood: Hood the Email bot belongs to.
    &#34;&#34;&#34;
    await email.delete()
    return Response(status_code=status.HTTP_204_NO_CONTENT)</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.email_message_create"><code class="name flex">
<span>async def <span class="ident">email_message_create</span></span>(<span>message: <a title="kibicara.platforms.email.webapi.BodyMessage" href="#kibicara.platforms.email.webapi.BodyMessage">BodyMessage</a>, hood=Depends(get_hood_unauthorized))</span>
</code></dt>
<dd>
<div class="desc"><p>Receive a message from the MDA and pass it to the censor.</p>
<p>:param message: BodyMessage object, holds the message.
:param hood: Hood the Email bot belongs to.
:return: returns status code 201 if the message is accepted by the censor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.post(
    &#39;/messages/&#39;,
    status_code=status.HTTP_201_CREATED,
    # TODO response_model
    operation_id=&#39;send_message&#39;,
)
async def email_message_create(
    message: BodyMessage, hood=Depends(get_hood_unauthorized)
):
    &#34;&#34;&#34;Receive a message from the MDA and pass it to the censor.

    :param message: BodyMessage object, holds the message.
    :param hood: Hood the Email bot belongs to.
    :return: returns status code 201 if the message is accepted by the censor.
    &#34;&#34;&#34;
    for receiver in await Email.objects.filter(hood=hood).all():
        if message.secret == receiver.secret:
            # pass message.text to bot.py
            if await spawner.get(hood).publish(Message(message.text)):
                logger.warning(&#34;Message was accepted: &#34; + message.text)
                return {}
            else:
                logger.warning(&#34;Message was&#39;t accepted: &#34; + message.text)
                raise HTTPException(
                    status_code=status.HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS
                )
    logger.warning(
        &#34;Someone is trying to submit an email without the correct API secret&#34;
    )
    raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.email_read"><code class="name flex">
<span>async def <span class="ident">email_read</span></span>(<span>email=Depends(get_email))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.get(
    &#39;/{email_id}&#39;,
    # TODO response_model
    operation_id=&#39;get_email&#39;,
)
async def email_read(email=Depends(get_email)):
    return email</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.email_read_all"><code class="name flex">
<span>async def <span class="ident">email_read_all</span></span>(<span>hood=Depends(get_hood))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.get(
    &#39;/&#39;,
    # TODO response_model
    operation_id=&#39;get_emails&#39;,
)
async def email_read_all(hood=Depends(get_hood)):
    return await Email.objects.filter(hood=hood).select_related(&#39;hood&#39;).all()</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.email_read_all_public"><code class="name flex">
<span>async def <span class="ident">email_read_all_public</span></span>(<span>hood=Depends(get_hood_unauthorized))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.get(
    &#39;/public&#39;,
    # TODO response_model
    operation_id=&#39;get_emails_public&#39;,
)
async def email_read_all_public(hood=Depends(get_hood_unauthorized)):
    if hood.email_enabled:
        emails = await Email.objects.filter(hood=hood).all()
        return [BodyEmailPublic(name=email.name) for email in emails]
    return []</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.email_start"><code class="name flex">
<span>async def <span class="ident">email_start</span></span>(<span>hood=Depends(get_hood))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.post(
    &#39;/start&#39;,
    status_code=status.HTTP_200_OK,
    # TODO response_model
    operation_id=&#39;start_email&#39;,
)
async def email_start(hood=Depends(get_hood)):
    await hood.update(email_enabled=True)
    spawner.get(hood).start()
    return {}</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.email_status"><code class="name flex">
<span>async def <span class="ident">email_status</span></span>(<span>hood=Depends(get_hood))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.get(
    &#39;/status&#39;,
    status_code=status.HTTP_200_OK,
    # TODO response_model
    operation_id=&#39;status_email&#39;,
)
async def email_status(hood=Depends(get_hood)):
    return {&#39;status&#39;: spawner.get(hood).status.name}</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.email_stop"><code class="name flex">
<span>async def <span class="ident">email_stop</span></span>(<span>hood=Depends(get_hood))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.post(
    &#39;/stop&#39;,
    status_code=status.HTTP_200_OK,
    # TODO response_model
    operation_id=&#39;stop_email&#39;,
)
async def email_stop(hood=Depends(get_hood)):
    await hood.update(email_enabled=False)
    spawner.get(hood).stop()
    return {}</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.email_subscribe"><code class="name flex">
<span>async def <span class="ident">email_subscribe</span></span>(<span>subscriber: <a title="kibicara.platforms.email.webapi.BodySubscriber" href="#kibicara.platforms.email.webapi.BodySubscriber">BodySubscriber</a>, hood=Depends(get_hood_unauthorized))</span>
</code></dt>
<dd>
<div class="desc"><p>Send a confirmation mail to subscribe to messages via email.</p>
<p>:param subscriber: Subscriber object, holds the email address.
:param hood: Hood the Email bot belongs to.
:return: Returns status code 200 after sending confirmation email.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.post(
    &#39;/subscribe/&#39;,
    status_code=status.HTTP_202_ACCEPTED,
    operation_id=&#39;subscribe&#39;,
    response_model=BaseModel,
)
async def email_subscribe(
    subscriber: BodySubscriber, hood=Depends(get_hood_unauthorized)
):
    &#34;&#34;&#34;Send a confirmation mail to subscribe to messages via email.

    :param subscriber: Subscriber object, holds the email address.
    :param hood: Hood the Email bot belongs to.
    :return: Returns status code 200 after sending confirmation email.
    &#34;&#34;&#34;
    token = to_token(hood=hood.id, email=subscriber.email)
    confirm_link = &#39;%s/hoods/%d/email-confirm?token=%s&#39; % (
        config[&#39;frontend_url&#39;],
        hood.id,
        token,
    )
    try:
        subs = await EmailSubscribers.objects.filter(email=subscriber.email).all()
        if subs:
            raise HTTPException(status_code=status.HTTP_409_CONFLICT)
        email.send_email(
            subscriber.email,
            &#34;Subscribe to Kibicara &#34; + hood.name,
            sender=hood.name,
            body=&#39;To confirm your subscription, follow this link: &#39; + confirm_link,
        )
        return {}
    except ConnectionRefusedError:
        logger.info(token)
        logger.error(&#34;Sending subscription confirmation email failed.&#34;, exc_info=True)
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY)
    except SMTPException:
        logger.info(token)
        logger.error(&#34;Sending subscription confirmation email failed.&#34;, exc_info=True)
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY)</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.email_subscribe_confirm"><code class="name flex">
<span>async def <span class="ident">email_subscribe_confirm</span></span>(<span>token, hood=Depends(get_hood_unauthorized))</span>
</code></dt>
<dd>
<div class="desc"><p>Confirm a new subscriber and add them to the database.</p>
<p>:param token: encrypted JSON token, holds the email of the subscriber.
:param hood: Hood the Email bot belongs to.
:return: Returns status code 200 after adding the subscriber to the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.post(
    &#39;/subscribe/confirm/{token}&#39;,
    status_code=status.HTTP_201_CREATED,
    operation_id=&#39;confirm_subscriber&#39;,
    response_model=BaseModel,
)
async def email_subscribe_confirm(token, hood=Depends(get_hood_unauthorized)):
    &#34;&#34;&#34;Confirm a new subscriber and add them to the database.

    :param token: encrypted JSON token, holds the email of the subscriber.
    :param hood: Hood the Email bot belongs to.
    :return: Returns status code 200 after adding the subscriber to the database.
    &#34;&#34;&#34;
    payload = from_token(token)
    # If token.hood and url.hood are different, raise an error:
    if hood.id is not payload[&#39;hood&#39;]:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST)
    try:
        await EmailSubscribers.objects.create(hood=hood.id, email=payload[&#39;email&#39;])
        return {}
    except IntegrityError:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT)</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.email_unsubscribe"><code class="name flex">
<span>async def <span class="ident">email_unsubscribe</span></span>(<span>token, hood=Depends(get_hood_unauthorized))</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a subscriber from the database when they click on an unsubscribe link.</p>
<p>:param token: encrypted JSON token, holds subscriber email + hood.id.
:param hood: Hood the Email bot belongs to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.delete(
    &#39;/unsubscribe/{token}&#39;,
    status_code=status.HTTP_204_NO_CONTENT,
    operation_id=&#39;unsubscribe&#39;,
)
async def email_unsubscribe(token, hood=Depends(get_hood_unauthorized)):
    &#34;&#34;&#34;Remove a subscriber from the database when they click on an unsubscribe link.

    :param token: encrypted JSON token, holds subscriber email + hood.id.
    :param hood: Hood the Email bot belongs to.
    &#34;&#34;&#34;
    try:
        logger.warning(&#34;token is: &#34; + token)
        payload = from_token(token)
        # If token.hood and url.hood are different, raise an error:
        if hood.id is not payload[&#39;hood&#39;]:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST)
        subscriber = await EmailSubscribers.objects.filter(
            hood=payload[&#39;hood&#39;], email=payload[&#39;email&#39;]
        ).get()
        await subscriber.delete()
        return Response(status_code=status.HTTP_204_NO_CONTENT)
    except NoMatch:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)
    except exceptions.CryptoError:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST)</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.get_email"><code class="name flex">
<span>async def <span class="ident">get_email</span></span>(<span>email_id: int, hood=Depends(get_hood))</span>
</code></dt>
<dd>
<div class="desc"><p>Get Email row by hood.
You can specify an email_id to nail it down, but it works without as well.</p>
<p>:param hood: Hood the Email bot belongs to.
:return: Email row of the found email bot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_email(email_id: int, hood=Depends(get_hood)):
    &#34;&#34;&#34;Get Email row by hood.
    You can specify an email_id to nail it down, but it works without as well.

    :param hood: Hood the Email bot belongs to.
    :return: Email row of the found email bot.
    &#34;&#34;&#34;
    try:
        return await Email.objects.get(id=email_id, hood=hood)
    except NoMatch:
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.get_subscriber"><code class="name flex">
<span>async def <span class="ident">get_subscriber</span></span>(<span>subscriber_id: int, hood=Depends(get_hood))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_subscriber(subscriber_id: int, hood=Depends(get_hood)):
    try:
        return await EmailSubscribers.objects.get(id=subscriber_id, hood=hood)
    except NoMatch:
        return HTTPException(status_code=status.HTTP_404_NOT_FOUND)</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.subscribers_read"><code class="name flex">
<span>async def <span class="ident">subscribers_read</span></span>(<span>subscriber=Depends(get_subscriber))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.get(
    &#39;/subscribers/{subscriber_id}&#39;,
    # TODO response_model
    operation_id=&#39;get_subscriber&#39;,
)
async def subscribers_read(subscriber=Depends(get_subscriber)):
    return subscriber</code></pre>
</details>
</dd>
<dt id="kibicara.platforms.email.webapi.subscribers_read_all"><code class="name flex">
<span>async def <span class="ident">subscribers_read_all</span></span>(<span>hood=Depends(get_hood))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@router.get(
    &#39;/subscribers/&#39;,
    # TODO response_model
    operation_id=&#39;get_subscribers&#39;,
)
async def subscribers_read_all(hood=Depends(get_hood)):
    return await EmailSubscribers.objects.filter(hood=hood).all()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="kibicara.platforms.email.webapi.BodyEmail"><code class="flex name class">
<span>class <span class="ident">BodyEmail</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BodyEmail(BaseModel):
    name: str

    @validator(&#39;name&#39;)
    def valid_prefix(cls, value):
        if not value.startswith(&#39;kibicara-&#39;):
            raise ValueError(&#39;Recipient address didn\&#39;t start with kibicara-&#39;)
        return value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kibicara.platforms.email.webapi.BodyEmail.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="kibicara.platforms.email.webapi.BodyEmail.valid_prefix"><code class="name flex">
<span>def <span class="ident">valid_prefix</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validator(&#39;name&#39;)
def valid_prefix(cls, value):
    if not value.startswith(&#39;kibicara-&#39;):
        raise ValueError(&#39;Recipient address didn\&#39;t start with kibicara-&#39;)
    return value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="kibicara.platforms.email.webapi.BodyEmailPublic"><code class="flex name class">
<span>class <span class="ident">BodyEmailPublic</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BodyEmailPublic(BaseModel):
    name: str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kibicara.platforms.email.webapi.BodyEmailPublic.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="kibicara.platforms.email.webapi.BodyMessage"><code class="flex name class">
<span>class <span class="ident">BodyMessage</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>This model shows which values are supplied by the MDA listener script. </p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BodyMessage(BaseModel):
    &#34;&#34;&#34; This model shows which values are supplied by the MDA listener script. &#34;&#34;&#34;

    text: str
    secret: str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kibicara.platforms.email.webapi.BodyMessage.secret"><code class="name">var <span class="ident">secret</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="kibicara.platforms.email.webapi.BodyMessage.text"><code class="name">var <span class="ident">text</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="kibicara.platforms.email.webapi.BodySubscriber"><code class="flex name class">
<span>class <span class="ident">BodySubscriber</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>This model holds the email address of a fresh subscriber. </p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BodySubscriber(BaseModel):
    &#34;&#34;&#34; This model holds the email address of a fresh subscriber. &#34;&#34;&#34;

    email: str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kibicara.platforms.email.webapi.BodySubscriber.email"><code class="name">var <span class="ident">email</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="kibicara.platforms.email" href="index.html">kibicara.platforms.email</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="kibicara.platforms.email.webapi.email_create" href="#kibicara.platforms.email.webapi.email_create">email_create</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.email_delete" href="#kibicara.platforms.email.webapi.email_delete">email_delete</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.email_message_create" href="#kibicara.platforms.email.webapi.email_message_create">email_message_create</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.email_read" href="#kibicara.platforms.email.webapi.email_read">email_read</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.email_read_all" href="#kibicara.platforms.email.webapi.email_read_all">email_read_all</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.email_read_all_public" href="#kibicara.platforms.email.webapi.email_read_all_public">email_read_all_public</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.email_start" href="#kibicara.platforms.email.webapi.email_start">email_start</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.email_status" href="#kibicara.platforms.email.webapi.email_status">email_status</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.email_stop" href="#kibicara.platforms.email.webapi.email_stop">email_stop</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.email_subscribe" href="#kibicara.platforms.email.webapi.email_subscribe">email_subscribe</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.email_subscribe_confirm" href="#kibicara.platforms.email.webapi.email_subscribe_confirm">email_subscribe_confirm</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.email_unsubscribe" href="#kibicara.platforms.email.webapi.email_unsubscribe">email_unsubscribe</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.get_email" href="#kibicara.platforms.email.webapi.get_email">get_email</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.get_subscriber" href="#kibicara.platforms.email.webapi.get_subscriber">get_subscriber</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.subscribers_read" href="#kibicara.platforms.email.webapi.subscribers_read">subscribers_read</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.subscribers_read_all" href="#kibicara.platforms.email.webapi.subscribers_read_all">subscribers_read_all</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="kibicara.platforms.email.webapi.BodyEmail" href="#kibicara.platforms.email.webapi.BodyEmail">BodyEmail</a></code></h4>
<ul class="">
<li><code><a title="kibicara.platforms.email.webapi.BodyEmail.name" href="#kibicara.platforms.email.webapi.BodyEmail.name">name</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.BodyEmail.valid_prefix" href="#kibicara.platforms.email.webapi.BodyEmail.valid_prefix">valid_prefix</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kibicara.platforms.email.webapi.BodyEmailPublic" href="#kibicara.platforms.email.webapi.BodyEmailPublic">BodyEmailPublic</a></code></h4>
<ul class="">
<li><code><a title="kibicara.platforms.email.webapi.BodyEmailPublic.name" href="#kibicara.platforms.email.webapi.BodyEmailPublic.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kibicara.platforms.email.webapi.BodyMessage" href="#kibicara.platforms.email.webapi.BodyMessage">BodyMessage</a></code></h4>
<ul class="">
<li><code><a title="kibicara.platforms.email.webapi.BodyMessage.secret" href="#kibicara.platforms.email.webapi.BodyMessage.secret">secret</a></code></li>
<li><code><a title="kibicara.platforms.email.webapi.BodyMessage.text" href="#kibicara.platforms.email.webapi.BodyMessage.text">text</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kibicara.platforms.email.webapi.BodySubscriber" href="#kibicara.platforms.email.webapi.BodySubscriber">BodySubscriber</a></code></h4>
<ul class="">
<li><code><a title="kibicara.platforms.email.webapi.BodySubscriber.email" href="#kibicara.platforms.email.webapi.BodySubscriber.email">email</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>